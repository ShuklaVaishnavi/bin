import React, { useState, useCallback, useEffect } from 'react';
import ReactFlow, {
    Controls,
    addEdge,
    useNodesState,
    useEdgesState,
    ReactFlowProvider,
    Node,
    Connection,
    Edge,
    NodeMouseHandler,
} from 'react-flow-renderer';
import axios from 'axios';

const initialNodes: Node[] = [];
const initialEdges: Edge[] = [];

const calculateNodeWidth = (label: string) => (label.length > 5 ? label.length * 13 + 40 : 50);
const calculateNodeHeight = () => 40;

const getLayoutedNodes = (nodes: Node[], edges: Edge[], direction: string): Node[] => {
    const verticalSpacing = 50;
    const horizontalSpacing = 50;
    const nodeMap: { [key: string]: Node } = {};
    nodes.forEach((node) => (nodeMap[node.id] = node));
    const parentMap: { [key: string]: string[] } = {};
    edges.forEach((edge) => {
        if (!parentMap[edge.source]) {
            parentMap[edge.source] = [];
        }
        parentMap[edge.source].push(edge.target);
    });
    const calculateSubtreeWidth = (nodeId: string): number => {
        const children = parentMap[nodeId];
        const node = nodeMap[nodeId];
        if (!children || children.length === 0) {
            return calculateNodeWidth(node.data.label);
        }
        return children.reduce((width, childId) => width + calculateSubtreeWidth(childId) + horizontalSpacing, -horizontalSpacing);
    };
    const calculatePositions = (nodeId: string, depth: number, position: { x: number; y: number }) => {
        const node = nodeMap[nodeId];
        if (!node) return;
        node.position = { x: position.x, y: position.y };
        const children = parentMap[nodeId];
        if (children && children.length > 0) {
            const totalWidth = children.reduce((width, childId) => width + calculateSubtreeWidth(childId) + horizontalSpacing, -horizontalSpacing);
            let offsetX = position.x - totalWidth / 2 + calculateNodeWidth(node.data.label) / 2;
            children.forEach((childId) => {
                const childWidth = calculateSubtreeWidth(childId);
                calculatePositions(childId, depth + 1, {
                    x: offsetX + childWidth / 2 - calculateNodeWidth(node.data.label) / 2,
                    y: position.y + calculateNodeHeight() + verticalSpacing,
                });
                offsetX += childWidth + horizontalSpacing;
            });
        }
    };
    const rootNodeId = nodes.find((node) => !edges.some((edge) => edge.target === node.id))?.id;
    if (rootNodeId) {
        calculatePositions(rootNodeId, 0, { x: 0, y: 0 });
    }
    return nodes;
};

const App: React.FC = () => {
    const [nodes, setNodes, onNodesChange] = useNodesState<Node>(initialNodes);
    const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>(initialEdges);
    const [allNodes, setAllNodes] = useState<Node[]>([]);
    const [allEdges, setAllEdges] = useState<Edge[]>([]);
    const [viewMode, setViewMode] = useState<'full' | 'parent-child'>('full');
    const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
    const [taskId, setTaskId] = useState<string>("");

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setTaskId(e.target.value);
    };

    const fetchNodes = async () => {
        try {
            const response = await axios.get<NodeData[]>("http://localhost:8180/swagger/getson", { params: { taskId: taskId } });
            const data = response.data;
            const processedNodes: Node[] = data.map((item) => ({
                id: item.node,
                type: item.type || 'default',
                data: { label: item.node, value: item.value, graphdepth: item.graphDepth, parentNode: item.parentNode },
                position: { x: 0, y: 0 },
                draggable: true,
                hidden: true,
                style: { width: calculateNodeWidth(item.node), backgroundColor: '#809f9f' },
            }));
            const processedEdges: Edge[] = data.filter((item) => item.parentNode).map((item) => ({
                id: `${item.parentNode}-${item.node}`,
                source: item.parentNode as string,
                target: item.node,
            }));
            setAllNodes(processedNodes);
            setAllEdges(processedEdges);
            setNodes(processedNodes.map((node) => ({ ...node, hidden: false })));
            setEdges(processedEdges);
        } catch (error) {
            console.error('Error fetching node data', error);
        }
    };

    const expandNode = useCallback((node: Node) => {
        const childNodes = allNodes.filter((n) => n.data.parentNode === node.id);
        if (childNodes.length > 0) {
            const newNodes = [...nodes];
            const newEdges = [...edges];
            childNodes.forEach((child) => {
                const len = calculateNodeWidth(child.data.label);
                const position = { x: node.position.x + Math.random() * 200, y: node.position.y + 100 };
                newNodes.push({ ...child, position, hidden: false, style: { width: len, backgroundColor: '#809f9f' } });
                newEdges.push({ id: `${node.id}-${child.id}`, source: node.id, target: child.id, type: 'bezier', style: { strokeWidth: 1, stroke: '#363636' } });
            });
            setNodes(getLayoutedNodes(newNodes, newEdges, 'TB'));
            setEdges(newEdges);
        }
    }, [allNodes, nodes, edges]);

    const onNodeClick: NodeMouseHandler = useCallback((event, node) => {
        setSelectedNodeId(node.id);
        if (viewMode === 'parent-child') {
            const parent = allNodes.find((n) => n.id === node.data.parentNode);
            const children = allNodes.filter((n) => n.data.parentNode === node.id);
            const newNodes = [node, ...(parent ? [parent] : []), ...children];
            const newEdges = allEdges.filter((edge) => newNodes.some((n) => n.id === edge.source && newNodes.some((n) => n.id === edge.target)));
            setNodes(getLayoutedNodes(newNodes, newEdges, 'TB'));
            setEdges(newEdges);
        } else {
            expandNode(node);
        }
    }, [viewMode, allNodes, allEdges, expandNode]);

    const toggleViewMode = () => {
        setViewMode(viewMode === 'full' ? 'parent-child' : 'full');
    };

    useEffect(() => {
        if (viewMode === 'full') {
            setNodes(getLayoutedNodes(allNodes, allEdges, 'TB'));
            setEdges(allEdges);
        } else if (selectedNodeId) {
            const selectedNode = allNodes.find((node) => node.id === selectedNodeId);
            if (selectedNode) {
                onNodeClick(null, selectedNode);
            }
        }
    }, [viewMode, allNodes, allEdges, selectedNodeId, onNodeClick]);

    return (
        <div style={{ width: '100%', height: '100vh' }}>
            <div style={{ display: 'flex', padding: '10px', background: '#f0f0f0' }}>
                <label>
                    Task ID:
                    <input type="text" value={taskId} onChange={handleInputChange} />
                </label>
                <button onClick={fetchNodes}>Fetch Nodes</button>
                <button onClick={toggleViewMode}>
                    {viewMode === 'full' ? 'Switch to Parent-Child View' : 'Switch to Full View'}
                </button>
            </div>
            <ReactFlowProvider>
                <div style={{ width: '100%', height: 'calc(100vh - 50px)' }}>
                    <ReactFlow
                        nodes={nodes}
                        edges={edges}
                        onNodesChange={onNodesChange}
                        onEdgesChange={onEdgesChange}
                        onNodeClick={onNodeClick}
                        fitView
                    >
                        <Controls />
                    </ReactFlow>
                </div>
            </ReactFlowProvider>
        </div>
    );
};

export default App;

 

