const App: React.FC = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState<Node>(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>(initialEdges);
  const [allNodes, setAllNodes] = useState<Node[]>([]);
  const [allEdges, setAllEdges] = useState<Edge[]>([]);
  const [direction, setDirection] = useState('TB');
  const [selectedParentNode, setSelectedParentNode] = useState<string>("");
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());
  const [highlightedNode, setHighlightedNode] = useState<string | null>(null);
  const [selectedNodeData, setSelectedNodeData] = useState<NodeData[]>([]);
  const [apiData, setApiData] = useState<NodeData[]>([]);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [toolTip, setToolTip] = useState<{ visible: boolean; content: string; position: { x: number; y: number } } | null>(null);
  const [taskId, setTaskId] = useState<string>("");
  
  const onNodeMouseEnter = (event: React.MouseEvent, node: Node) => {
    setToolTip({
      visible: true,
      content: `ID: ${node.data.label.replace(/</g, "&lt;").replace(/>/g, "&gt;")}\nValue: ${node.data.value}\nGraph Depth: ${node.data.graphDepth}\nParent Node: ${node.data.parentNode}`,
      position: {
        x: event.clientX,
        y: event.clientY,
      },
    });
  };
  
  const onNodeMouseLeave = () => {
    setToolTip(null);
  };
  
  const uniqueParentNodes = Array.from(new Set(allNodes.map((node) => node.data.parentNode))).filter(Boolean) as string[];
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setTaskId(e.target.value);
  };

  const fetchNodes = async () => {
    try {
      const response = await axios.get<NodeData[]>("http://localhost:8180/swagger/getson", { params: { taskId: taskId } });
      setApiData(response.data);
      const data = response.data;
      let processedNodes: Node[] = data.map((item) => ({
        id: item.node,
        type: item.type || "default",
        data: {
          label: item.node,
          value: item.value,
          graphDepth: item.graphDepth,
          parentNode: item.parentNode,
        },
        position: { x: 0, y: 0 },
        draggable: true,
        hidden: true,
        style: {
          width: item.node.length > 5 ? item.node.length * 10 : 100,
          backgroundColor: getNodeColor(item.type || ""),
        },
      }));
  
      const getUniqueId = (nodes: Node[]) => {
        const uniqueMap = new Map<string, Node>();
        nodes.forEach(item => {
          uniqueMap.set(item.id, item);
        });
        return Array.from(uniqueMap.values());
      };
  
      const nodeArr = getUniqueId(processedNodes);
      processedNodes = nodeArr;
  
      const processedEdges: Edge[] = data.filter((item) => item.parentNode).map((item) => ({
        id: `${item.parentNode}-${item.node}`,
        source: item.parentNode as string,
        target: item.node,
      }));
  
      setAllNodes(processedNodes);
      setAllEdges(processedEdges);
      setNodes(processedNodes.map((node) => ({
        ...node,
        position: { x: 0, y: 0 },
        draggable: true,
        hidden: true,
      })));
      if (processedNodes.length > 0) {
        setNodes([...processedNodes.slice(0, 1), { ...processedNodes[0], hidden: false }]);
      }
    } catch (error) {
      console.error("Error fetching nodes:", error);
    }
  };

  const handleExpandNode = (nodeId: string) => {
    const expanded = new Set(expandedNodes);
    expanded.add(nodeId);
    setExpandedNodes(expanded);
  
    const nodesToShow = allNodes.filter(node => node.id === nodeId || node.data.parentNode === nodeId);
    setNodes(prevNodes => prevNodes.map(node => ({
      ...node,
      hidden: !nodesToShow.some(n => n.id === node.id)
    })));
  };

  const handleNodeClick: NodeMouseHandler = (event, node) => {
    handleExpandNode(node.id);
    setSelectedNodeId(node.id);
  };

  useEffect(() => {
    if (taskId) {
      fetchNodes();
    }
  }, [taskId]);

  useEffect(() => {
    if (allNodes.length > 0 && direction) {
      const layoutedNodes = getLayoutedNodes(allNodes, allEdges, direction);
      setNodes(layoutedNodes);
    }
  }, [allNodes, allEdges, direction]);

  return (
    <ToolkitTheme>
      <AppFrame>
        <div style={graphContainerStyles}>
          <div style={navbarStyles}>
            <div style={controlsLabelStyles}>Direction:</div>
            <select style={controlsSelectStyles} value={direction} onChange={(e) => setDirection(e.target.value)}>
              <option value="TB">Top-Bottom</option>
              <option value="BT">Bottom-Top</option>
              <option value="LR">Left-Right</option>
              <option value="RL">Right-Left</option>
            </select>
            <div>
              <input type="text" value={taskId} onChange={handleInputChange} style={controlsInputStyles} placeholder="Enter Task ID" />
              <button onClick={fetchNodes} style={buttonStyles}>Fetch Data</button>
            </div>
            <div>
              <div style={controlsLabelStyles}>Select Parent Node:</div>
              <select
                style={controlsSelectStyles}
                value={selectedParentNode}
                onChange={(e) => setSelectedParentNode(e.target.value)}
              >
                <option value="">All</option>
                {uniqueParentNodes.map((parentNode) => (
                  <option key={parentNode} value={parentNode}>
                    {parentNode}
                  </option>
                ))}
              </select>
            </div>
          </div>
          <div style={reactflowWrapperStyles}>
            <ReactFlowProvider>
              <ReactFlow
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onNodeClick={handleNodeClick}
                onNodeMouseEnter={onNodeMouseEnter}
                onNodeMouseLeave={onNodeMouseLeave}
                fitView
              >
                <Controls />
              </ReactFlow>
              {toolTip && toolTip.visible && (
                <div
                  style={{
                    position: "absolute",
                    top: toolTip.position.y + 10,
                    left: toolTip.position.x + 10,
                    backgroundColor: "#fff",
                    border: "1px solid #ccc",
                    padding: "5px",
                    zIndex: 1000,
                    pointerEvents: "none",
                  }}
                >
                  <div dangerouslySetInnerHTML={{ __html: toolTip.content.replace(/\n/g, "<br/>") }} />
                </div>
              )}
            </ReactFlowProvider>
          </div>
        </div>
      </AppFrame>
    </ToolkitTheme>
  );
};

export default App;
